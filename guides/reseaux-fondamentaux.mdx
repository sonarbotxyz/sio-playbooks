---
title: "Réseaux — Fondamentaux"
description: "Modèle OSI, TCP/IP, adressage IP, masques de sous-réseau, CIDR, ARP, DNS, DHCP"
category: "Reseaux"
tags: ["réseaux", "osi", "tcp/ip", "ip", "sous-réseau", "dns", "dhcp"]
difficulty: "Débutant"
---

# Réseaux -- Fondamentaux


---

## Table des matieres

1. [1. Pourquoi les réseaux](#1-pourquoi-les-rseaux)
2. [2. Le modèle OSI](#2-le-modle-osi)
3. [3. Le modèle TCP/IP](#3-le-modle-tcpip)
4. [4. Supports de transmission](#4-supports-de-transmission)
5. [5. Topologies réseau](#5-topologies-rseau)
6. [6. Equipements réseau](#6-equipements-rseau)
7. [7. Adressage IPv4](#7-adressage-ipv4)
8. [8. Masques de sous-réseau](#8-masques-de-sous-rseau)
9. [9. Découpage en sous-réseaux (subnetting)](#9-dcoupage-en-sous-rseaux-subnetting)
10. [10. Protocole ARP](#10-protocole-arp)
11. [11. Protocole ICMP](#11-protocole-icmp)
12. [12. DNS (Domain Name System)](#12-dns-domain-name-system)
13. [13. DHCP (Dynamic Host Configuration Protocol)](#13-dhcp-dynamic-host-configuration-protocol)
14. [14. TCP vs UDP](#14-tcp-vs-udp)
15. [15. NAT et PAT](#15-nat-et-pat)
16. [16. IPv6](#16-ipv6)
17. [17. Exercices corrigés](#17-exercices-corrigs)
18. [18. Résumé des formules essentielles](#18-rsum-des-formules-essentielles)
19. [19. Tableau de référence : puissances de 2](#19-tableau-de-rfrence-puissances-de-2)
20. [20. Tableau de référence : conversion rapide des masques](#20-tableau-de-rfrence-conversion-rapide-des-masques)

---

---

## 1. Pourquoi les réseaux

Un réseau informatique est un ensemble d'équipements (ordinateurs, serveurs, imprimantes, téléphones, objets connectés) reliés entre eux afin de pouvoir échanger des données.

### 1.1 Les besoins fondamentaux

**Communication** : permettre à deux ou plusieurs machines d'échanger des informations (messages, fichiers, flux audio/vidéo) indépendamment de leur localisation géographique.

**Partage de ressources** : mutualiser des équipements coûteux (imprimantes, serveurs de stockage, bases de données) au lieu de les dupliquer sur chaque poste.

**Accès centralisé aux données** : stocker les fichiers sur un serveur central pour garantir la cohérence, la sauvegarde et la sécurité des données.

**Internet** : interconnecter des millions de réseaux hétérogènes à l'échelle mondiale grâce à un ensemble de protocoles standardisés (TCP/IP).

### 1.2 Classification des réseaux par étendue

| Sigle | Nom complet | Portée | Exemple |
|-------|-------------|--------|---------|
| PAN | Personal Area Network | Quelques mètres | Bluetooth entre un téléphone et des écouteurs |
| LAN | Local Area Network | Un bâtiment, un site | Réseau d'une entreprise, d'un lycée |
| MAN | Metropolitan Area Network | Une ville | Réseau reliant plusieurs sites d'une université |
| WAN | Wide Area Network | Pays, continent, monde | Internet, réseau MPLS d'un opérateur |

### 1.3 Modes de communication

- **Unicast** : un émetteur vers un seul destinataire.
- **Broadcast** : un émetteur vers tous les hôtes du réseau local.
- **Multicast** : un émetteur vers un groupe d'hôtes identifiés.

---

## 2. Le modèle OSI

Le modèle OSI (Open Systems Interconnection) a été défini par l'ISO (International Organization for Standardization) en 1984. Il découpe la communication réseau en **7 couches**, chacune ayant un rôle précis. Ce modèle est un modèle de référence théorique : il sert à comprendre, concevoir et dépanner les réseaux, même si les protocoles réels suivent plutôt le modèle TCP/IP.

### 2.1 Vue d'ensemble des 7 couches

| Couche | Numéro | Nom | Unité de données (PDU) |
|--------|--------|-----|------------------------|
| 7 | Application | Données |
| 6 | Présentation | Données |
| 5 | Session | Données |
| 4 | Transport | Segment (TCP) / Datagramme (UDP) |
| 3 | Réseau | Paquet |
| 2 | Liaison de données | Trame |
| 1 | Physique | Bit |

Moyen mnémotechnique (du bas vers le haut) : **P**our **L**e **R**éseau **T**out **S**e **P**asse **A**utrement.

### 2.2 Couche 1 -- Physique

**Rôle** : transmettre des bits bruts (0 et 1) sur un support physique. Cette couche définit les caractéristiques électriques, mécaniques, optiques et radio du signal.

**Responsabilités** :
- Conversion des bits en signaux (électriques, lumineux, ondes radio).
- Définition du débit binaire (nombre de bits transmis par seconde).
- Spécification des connecteurs physiques (RJ45, SC, LC, etc.).
- Mode de transmission : simplex, half-duplex, full-duplex.
- Synchronisation des bits (horloge).

**Exemples de standards et protocoles** :
- Ethernet (IEEE 802.3) pour la partie physique.
- WiFi (IEEE 802.11) pour la partie radio.
- RS-232 (liaison série).
- DSL, SONET/SDH, T1/E1.

**Equipements** : câbles (cuivre, fibre), hub (concentrateur), répéteur.

### 2.3 Couche 2 -- Liaison de données

**Rôle** : assurer une communication fiable entre deux noeuds directement connectés (liaison point à point ou sur un même réseau local). Elle transforme le flux de bits bruts de la couche 1 en trames structurées.

**Responsabilités** :
- Adressage physique via les adresses MAC (Media Access Control) : identifiant unique de 48 bits (6 octets) gravé dans la carte réseau, noté en hexadécimal (ex. : `AA:BB:CC:DD:EE:FF`).
- Détection et éventuellement correction des erreurs (CRC -- Cyclic Redundancy Check).
- Contrôle d'accès au support (CSMA/CD pour Ethernet filaire, CSMA/CA pour WiFi).
- Découpage du flux en trames (framing).

**Sous-couches IEEE** :
- **LLC** (Logical Link Control, IEEE 802.2) : interface avec la couche réseau.
- **MAC** (Media Access Control) : contrôle d'accès au support.

**Exemples de protocoles** :
- Ethernet (IEEE 802.3).
- WiFi (IEEE 802.11).
- PPP (Point-to-Point Protocol).
- HDLC (High-Level Data Link Control).
- Frame Relay.

**Equipements** : switch (commutateur), pont (bridge), carte réseau (NIC).

**Structure d'une trame Ethernet** :

| Champ | Taille | Description |
|-------|--------|-------------|
| Préambule | 7 octets | Synchronisation |
| SFD (Start Frame Delimiter) | 1 octet | Début de trame (10101011) |
| Adresse MAC destination | 6 octets | Destinataire |
| Adresse MAC source | 6 octets | Émetteur |
| EtherType / Length | 2 octets | Type de protocole couche 3 (0x0800 = IPv4, 0x0806 = ARP) |
| Données (payload) | 46 à 1500 octets | Contenu (paquet IP, etc.) |
| FCS (Frame Check Sequence) | 4 octets | CRC pour la détection d'erreurs |

### 2.4 Couche 3 -- Réseau

**Rôle** : assurer l'acheminement des paquets de bout en bout (de la source à la destination finale), à travers un ou plusieurs réseaux interconnectés. C'est la couche du routage.

**Responsabilités** :
- Adressage logique (adresses IP).
- Routage : détermination du meilleur chemin pour acheminer un paquet.
- Fragmentation et réassemblage des paquets lorsque le MTU (Maximum Transmission Unit) diffère entre les réseaux traversés.

**Exemples de protocoles** :
- IPv4, IPv6.
- ICMP (Internet Control Message Protocol).
- ARP (Address Resolution Protocol) -- souvent classé entre les couches 2 et 3.
- Protocoles de routage : RIP, OSPF, EIGRP, BGP.
- IPsec (chiffrement au niveau réseau).

**Equipements** : routeur, switch de couche 3 (switch L3).

### 2.5 Couche 4 -- Transport

**Rôle** : assurer le transport fiable (ou non) des données de bout en bout entre deux processus applicatifs. Cette couche segmente les données de la couche supérieure et gère le contrôle de flux et la détection d'erreurs de bout en bout.

**Responsabilités** :
- Segmentation des données et réassemblage.
- Multiplexage grâce aux numéros de port (identification des applications).
- Contrôle de flux (fenêtre glissante TCP).
- Contrôle de congestion (TCP).
- Fiabilité : accusés de réception, retransmission (TCP).

**Protocoles principaux** :
- **TCP** (Transmission Control Protocol) : orienté connexion, fiable.
- **UDP** (User Datagram Protocol) : sans connexion, non fiable, rapide.

**Equipements** : pare-feu (firewall) à état (stateful), répartiteur de charge (load balancer).

### 2.6 Couche 5 -- Session

**Rôle** : établir, gérer et terminer les sessions de communication entre deux applications. Une session est un dialogue organisé entre deux machines.

**Responsabilités** :
- Ouverture, maintien et fermeture des sessions.
- Synchronisation (points de reprise en cas de panne).
- Gestion du dialogue (qui parle quand : half-duplex ou full-duplex).

**Exemples** :
- NetBIOS.
- RPC (Remote Procedure Call).
- PPTP (couche session du tunnel VPN).
- SIP (Session Initiation Protocol, téléphonie VoIP -- couche 5 pour l'établissement de session).

### 2.7 Couche 6 -- Présentation

**Rôle** : assurer la mise en forme des données pour qu'elles soient compréhensibles par la couche application. Elle gère la traduction, le chiffrement et la compression.

**Responsabilités** :
- Traduction des formats de données (ASCII, EBCDIC, Unicode).
- Chiffrement et déchiffrement (SSL/TLS -- souvent classé ici).
- Compression et décompression des données.
- Sérialisation (conversion d'objets en flux de données).

**Exemples** :
- SSL/TLS (Secure Sockets Layer / Transport Layer Security).
- JPEG, GIF, PNG (formats d'image).
- MPEG, AVI (formats vidéo).
- ASCII, UTF-8.

### 2.8 Couche 7 -- Application

**Rôle** : fournir aux applications utilisateur l'interface d'accès au réseau. C'est la couche la plus proche de l'utilisateur final.

**Responsabilités** :
- Fournir des services réseau aux applications (courrier, transfert de fichiers, navigation web, etc.).
- Identification des partenaires de communication.
- Vérification de la disponibilité des ressources.

**Exemples de protocoles** :
- HTTP / HTTPS (web).
- FTP / SFTP / FTPS (transfert de fichiers).
- SMTP, POP3, IMAP (courrier électronique).
- DNS (résolution de noms).
- DHCP (attribution d'adresses IP).
- SSH (accès distant sécurisé).
- Telnet (accès distant non sécurisé).
- SNMP (supervision réseau).
- LDAP (annuaire).
- NFS, SMB/CIFS (partage de fichiers).

### 2.9 Encapsulation et décapsulation

L'encapsulation est le processus par lequel chaque couche ajoute un en-tête (et parfois un trailer) aux données reçues de la couche supérieure.

**Encapsulation (émission)** :

```
Couche 7-5 : [Données]
Couche 4   : [En-tête TCP/UDP] + [Données]                       = Segment
Couche 3   : [En-tête IP] + [Segment]                             = Paquet
Couche 2   : [En-tête Ethernet] + [Paquet] + [FCS]                = Trame
Couche 1   : Conversion en bits → signal électrique/optique/radio
```

**Décapsulation (réception)** : processus inverse. Chaque couche retire son en-tête et transmet les données à la couche supérieure.

Ce mécanisme garantit l'indépendance des couches : chaque couche n'a besoin de connaître que l'interface avec ses couches voisines.

---

## 3. Le modèle TCP/IP

### 3.1 Origine et philosophie

Le modèle TCP/IP a été développé par le département de la Défense américain (DoD) dans les années 1970, bien avant la formalisation du modèle OSI. Il est pragmatique, conçu pour fonctionner sur des réseaux hétérogènes et résister aux pannes (contexte militaire).

### 3.2 Les 4 couches

| Couche TCP/IP | Correspondance OSI | Protocoles principaux |
|---------------|--------------------|-----------------------|
| 4. Application | 7 + 6 + 5 | HTTP, FTP, SMTP, DNS, DHCP, SSH, SNMP |
| 3. Transport | 4 | TCP, UDP |
| 2. Internet | 3 | IP (v4/v6), ICMP, ARP, IGMP |
| 1. Accès réseau (Network Access) | 2 + 1 | Ethernet, WiFi, PPP, Frame Relay |

### 3.3 Pourquoi TCP/IP a gagné sur OSI

- **Implémentation réelle** : TCP/IP existait et fonctionnait avant qu'OSI ne soit finalisé. Les protocoles OSI (X.25, X.400, etc.) étaient complexes et peu déployés.
- **Internet** : TCP/IP est le socle d'Internet. Son adoption massive l'a rendu incontournable.
- **Simplicité** : 4 couches au lieu de 7, plus facile à implémenter.
- **Ouverture** : standards définis par des RFC (Request For Comments) librement accessibles, contre des normes ISO payantes.
- **Pragmatisme** : TCP/IP a été conçu par des ingénieurs pour résoudre des problèmes concrets, OSI par un comité pour couvrir tous les cas théoriques.

Cependant, le modèle OSI reste la référence pédagogique pour comprendre les réseaux car il offre une granularité plus fine.

---

## 4. Supports de transmission

### 4.1 Câble cuivre à paires torsadées (RJ45)

Le câble à paires torsadées est le support le plus répandu dans les réseaux locaux. Il est constitué de 4 paires de fils de cuivre torsadés entre eux pour limiter les interférences électromagnétiques (diaphonie).

**Connecteur** : RJ45 (Registered Jack 45), 8 broches.

**Types de blindage** :
- **UTP** (Unshielded Twisted Pair) : non blindé. Le plus courant et le moins cher.
- **FTP** (Foiled Twisted Pair) : blindage global par une feuille d'aluminium.
- **STP** (Shielded Twisted Pair) : blindage individuel de chaque paire.
- **SFTP** (Shielded Foiled Twisted Pair) : blindage individuel + blindage global.

**Catégories** :

| Catégorie | Débit maximal | Fréquence | Usage |
|-----------|--------------|-----------|-------|
| Cat 5 | 100 Mbit/s | 100 MHz | Obsolète |
| Cat 5e | 1 Gbit/s | 100 MHz | Encore répandu |
| Cat 6 | 1 Gbit/s (10 Gbit/s sur 55 m) | 250 MHz | Recommandé |
| Cat 6a | 10 Gbit/s (100 m) | 500 MHz | Datacenters, nouvelles installations |
| Cat 7 | 10 Gbit/s | 600 MHz | Environnements exigeants |
| Cat 8 | 25/40 Gbit/s | 2000 MHz | Datacenters, courtes distances (30 m) |

**Longueur maximale** : 100 mètres pour un segment (norme Ethernet).

**Câblage droit vs croisé** :
- **Câble droit** : relie deux équipements de types différents (PC vers switch).
- **Câble croisé** : relie deux équipements de même type (PC vers PC, switch vers switch).
- Note : la plupart des équipements modernes supportent l'Auto-MDI/MDI-X et détectent automatiquement le type de câblage nécessaire.

### 4.2 Fibre optique

La fibre optique transporte les données sous forme de signaux lumineux à travers un coeur en verre ou en plastique. Elle offre des débits très élevés, une immunité aux interférences électromagnétiques et des distances de transmission bien supérieures au cuivre.

**Structure** : coeur (propagation de la lumière), gaine optique (réflexion), revêtement de protection.

**Types de fibre** :

| Caractéristique | Multimode (MMF) | Monomode (SMF) |
|-----------------|----------------|-----------------|
| Diamètre du coeur | 50 ou 62,5 micromètres | 9 micromètres |
| Source lumineuse | LED | Laser |
| Distance | Jusqu'à 2 km | Jusqu'à 100 km et plus |
| Débit | Jusqu'à 10 Gbit/s (courte distance) | 10 Gbit/s à 100 Gbit/s et plus |
| Coût | Moins cher | Plus cher |
| Usage | LAN, datacenter (courte distance) | WAN, liaisons longue distance |

**Connecteurs courants** : SC (carré, click), LC (petit, click), ST (rond, baïonnette), MTP/MPO (multi-fibres).

### 4.3 Sans fil -- WiFi (IEEE 802.11)

Le WiFi utilise des ondes radio pour transmettre les données sans câblage.

**Normes principales** :

| Norme | Nom commercial | Fréquence | Débit théorique maximal | Année |
|-------|---------------|-----------|------------------------|-------|
| 802.11b | -- | 2,4 GHz | 11 Mbit/s | 1999 |
| 802.11a | -- | 5 GHz | 54 Mbit/s | 1999 |
| 802.11g | -- | 2,4 GHz | 54 Mbit/s | 2003 |
| 802.11n | WiFi 4 | 2,4 / 5 GHz | 600 Mbit/s | 2009 |
| 802.11ac | WiFi 5 | 5 GHz | 6,9 Gbit/s | 2013 |
| 802.11ax | WiFi 6 / 6E | 2,4 / 5 / 6 GHz | 9,6 Gbit/s | 2020 |

**Bande 2,4 GHz** : meilleure portée, traverse mieux les obstacles, mais seulement 3 canaux non recouvrants (1, 6, 11) et plus sujette aux interférences (micro-ondes, Bluetooth).

**Bande 5 GHz** : plus de canaux disponibles, moins d'interférences, débits plus élevés, mais portée réduite et moins bonne pénétration des murs.

**Sécurité WiFi** :
- WEP (Wired Equivalent Privacy) : obsolète, cassable en minutes.
- WPA (Wi-Fi Protected Access) : amélioration temporaire, TKIP.
- WPA2 : standard actuel, utilise AES-CCMP.
- WPA3 : dernière version, chiffrement renforcé, protection contre les attaques par dictionnaire.

---

## 5. Topologies réseau

La topologie décrit la manière dont les équipements sont interconnectés. On distingue la topologie physique (câblage réel) de la topologie logique (flux de données).

### 5.1 Topologie en bus

Tous les équipements sont connectés à un câble unique (le bus). Les données circulent dans les deux sens et chaque station reçoit toutes les trames.

- **Avantages** : simple, peu de câblage.
- **Inconvénients** : une rupture du câble coupe tout le réseau, collisions fréquentes, difficile à dépanner, mauvaises performances quand le nombre de stations augmente.
- **Usage** : réseaux Ethernet 10Base2 et 10Base5 (obsolètes).

### 5.2 Topologie en étoile

Chaque équipement est relié à un noeud central (hub ou switch). Toute communication passe par le centre.

- **Avantages** : une panne d'un câble n'affecte qu'un seul poste, facile à dépanner et à étendre.
- **Inconvénients** : le noeud central est un point de défaillance unique (SPOF), plus de câblage.
- **Usage** : topologie la plus utilisée aujourd'hui dans les LAN.

### 5.3 Topologie en anneau

Chaque équipement est relié au suivant, formant une boucle fermée. Les données circulent dans un seul sens (ou dans les deux sens dans un double anneau).

- **Avantages** : pas de collisions (accès contrôlé par jeton -- Token Ring).
- **Inconvénients** : une panne d'un noeud ou d'un câble coupe l'anneau (sauf double anneau), délai proportionnel au nombre de noeuds.
- **Usage** : Token Ring (IEEE 802.5), FDDI -- largement obsolètes.

### 5.4 Topologie maillée

Chaque équipement est relié à un ou plusieurs autres. Dans un maillage complet, chaque noeud est relié à tous les autres.

- **Avantages** : haute redondance, tolérance aux pannes (plusieurs chemins possibles), robustesse.
- **Inconvénients** : coût élevé (nombre de liaisons = n(n-1)/2 pour un maillage complet), complexité de gestion.
- **Usage** : coeurs de réseau, Internet (maillage partiel).

### 5.5 Topologie en arbre (hiérarchique)

Extension de la topologie en étoile : plusieurs étoiles interconnectées de manière hiérarchique via des switchs ou routeurs.

- **Avantages** : extensible, segmentation logique du réseau, organisation hiérarchique claire.
- **Inconvénients** : dépendance au noeud racine, panne d'un switch intermédiaire isole une branche.
- **Usage** : réseaux d'entreprise structurés en couches (accès, distribution, coeur).

---

## 6. Equipements réseau

### 6.1 Hub (concentrateur) -- Couche 1

Le hub reçoit un signal sur un port et le retransmet sur **tous les autres ports** sans distinction. Il ne comprend ni les adresses MAC ni les adresses IP.

- Fonctionne en half-duplex.
- Provoque des collisions (domaine de collision unique).
- Obsolète : remplacé par le switch.

### 6.2 Switch (commutateur) -- Couche 2

Le switch apprend les adresses MAC des équipements connectés à chaque port (table MAC ou table CAM). Il transmet les trames uniquement au port de destination, ce qui réduit les collisions.

- Chaque port constitue un domaine de collision séparé.
- Fonctionne en full-duplex.
- Peut créer des VLAN (Virtual LAN) pour segmenter logiquement le réseau.
- Un switch de couche 3 (L3) peut également effectuer du routage IP.

### 6.3 Routeur -- Couche 3

Le routeur interconnecte des réseaux différents (par exemple un LAN et Internet). Il prend ses décisions de transfert en fonction des adresses IP et de sa table de routage.

- Sépare les domaines de broadcast.
- Détermine le meilleur chemin grâce aux protocoles de routage (statique, RIP, OSPF, BGP).
- Effectue souvent la traduction d'adresses (NAT/PAT).
- Peut intégrer des fonctions de pare-feu, serveur DHCP, point d'accès WiFi (routeur domestique).

### 6.4 Point d'accès sans fil (AP) -- Couches 1 et 2

Le point d'accès permet aux équipements sans fil de se connecter au réseau filaire. Il fait le pont entre le réseau WiFi et le réseau Ethernet.

### 6.5 Pare-feu (firewall) -- Couches 3 à 7

Le pare-feu filtre le trafic réseau selon des règles définies par l'administrateur.

- **Pare-feu à filtrage de paquets** (couche 3-4) : filtre selon les adresses IP, les ports et le protocole.
- **Pare-feu à état (stateful)** (couche 4) : suit l'état des connexions TCP.
- **Pare-feu applicatif / proxy** (couche 7) : inspecte le contenu des paquets (URL, contenu HTTP, etc.).
- **UTM** (Unified Threat Management) : combine pare-feu, antivirus, IDS/IPS, filtrage URL, VPN.

---

## 7. Adressage IPv4

### 7.1 Structure d'une adresse IPv4

Une adresse IPv4 est un identifiant logique de **32 bits** (4 octets), noté en décimal pointé.

Exemple : `192.168.1.10`

```
Décimal :  192      .  168      .  1        .  10
Binaire :  11000000 .  10101000 .  00000001 .  00001010
```

Chaque octet va de 0 à 255 (soit 2^8 = 256 valeurs possibles).

Une adresse IP se décompose en deux parties :
- **Partie réseau** (Network ID) : identifie le réseau.
- **Partie hôte** (Host ID) : identifie la machine dans ce réseau.

La frontière entre ces deux parties est définie par le masque de sous-réseau.

### 7.2 Classes d'adresses (historique)

Le système de classes est historique (remplacé par CIDR depuis 1993) mais reste au programme du BTS.

| Classe | Plage du 1er octet | Bits de poids fort | Masque par défaut | Nb de réseaux | Nb d'hôtes par réseau |
|--------|-------------------|-------------------|-------------------|---------------|----------------------|
| A | 1 -- 126 | 0xxxxxxx | 255.0.0.0 (/8) | 126 | 16 777 214 |
| B | 128 -- 191 | 10xxxxxx | 255.255.0.0 (/16) | 16 384 | 65 534 |
| C | 192 -- 223 | 110xxxxx | 255.255.255.0 (/24) | 2 097 152 | 254 |
| D | 224 -- 239 | 1110xxxx | -- | Multicast | -- |
| E | 240 -- 255 | 1111xxxx | -- | Réservée (recherche) | -- |

**Identification rapide** : regarder le premier octet.
- 1 a 126 → classe A.
- 128 a 191 → classe B.
- 192 a 223 → classe C.

**Calcul du nombre d'hôtes** : 2^n - 2, ou n est le nombre de bits de la partie hôte. On soustrait 2 car l'adresse réseau (tous les bits hôte à 0) et l'adresse de broadcast (tous les bits hôte à 1) ne sont pas attribuables à des machines.

### 7.3 Adresses privées (RFC 1918)

Ces plages sont réservées aux réseaux internes et ne sont pas routables sur Internet :

| Classe | Plage privée | Masque par défaut | Nombre d'adresses |
|--------|-------------|-------------------|--------------------|
| A | 10.0.0.0 -- 10.255.255.255 | /8 | 16 777 216 |
| B | 172.16.0.0 -- 172.31.255.255 | /12 | 1 048 576 |
| C | 192.168.0.0 -- 192.168.255.255 | /16 | 65 536 |

Pour accéder à Internet depuis un réseau privé, il faut utiliser la **NAT** (Network Address Translation).

### 7.4 Adresses spéciales

| Adresse | Signification |
|---------|---------------|
| `0.0.0.0` | Adresse indéterminée. Utilisée par un client DHCP qui n'a pas encore d'adresse. Signifie aussi "toutes les interfaces" côté serveur. |
| `127.0.0.0/8` | Loopback (boucle locale). `127.0.0.1` est l'adresse localhost : la machine s'envoie des paquets à elle-même, sans passer par le réseau. |
| `255.255.255.255` | Broadcast limité. Envoi à tous les hôtes du réseau local. Non routé par les routeurs. |
| `169.254.0.0/16` | APIPA (Automatic Private IP Addressing). Adresse auto-attribuée quand aucun serveur DHCP ne répond. |

---

## 8. Masques de sous-réseau

### 8.1 Principe

Le masque de sous-réseau permet de distinguer la partie réseau de la partie hôte dans une adresse IP. Il a la même longueur qu'une adresse IP (32 bits). Ses bits sont constitués d'une suite continue de 1 (partie réseau) suivie d'une suite continue de 0 (partie hôte).

### 8.2 Notation décimale et CIDR

| CIDR | Masque décimal | Bits réseau | Bits hôte |
|------|---------------|-------------|-----------|
| /8 | 255.0.0.0 | 8 | 24 |
| /16 | 255.255.0.0 | 16 | 16 |
| /24 | 255.255.255.0 | 24 | 8 |
| /25 | 255.255.255.128 | 25 | 7 |
| /26 | 255.255.255.192 | 26 | 6 |
| /27 | 255.255.255.224 | 27 | 5 |
| /28 | 255.255.255.240 | 28 | 4 |
| /29 | 255.255.255.248 | 29 | 3 |
| /30 | 255.255.255.252 | 30 | 2 |

**Conversions utiles** :

```
/25 → 11111111.11111111.11111111.10000000 → 255.255.255.128
/26 → 11111111.11111111.11111111.11000000 → 255.255.255.192
/27 → 11111111.11111111.11111111.11100000 → 255.255.255.224
/28 → 11111111.11111111.11111111.11110000 → 255.255.255.240
/29 → 11111111.11111111.11111111.11111000 → 255.255.255.248
/30 → 11111111.11111111.11111111.11111100 → 255.255.255.252
```

### 8.3 Calcul de l'adresse réseau

L'adresse réseau s'obtient par un **ET logique (AND)** bit à bit entre l'adresse IP et le masque.

**Exemple** : IP = `192.168.1.130`, masque = `/25` (255.255.255.128)

Conversion en binaire :

```
IP     : 11000000.10101000.00000001.10000010
Masque : 11111111.11111111.11111111.10000000
```

ET logique bit à bit :

```
IP     : 11000000.10101000.00000001.10000010
Masque : 11111111.11111111.11111111.10000000
         ────────────────────────────────────
Réseau : 11000000.10101000.00000001.10000000
```

Conversion en décimal :

```
Réseau : 192.168.1.128
```

### 8.4 Calcul de l'adresse de broadcast

L'adresse de broadcast s'obtient en mettant tous les bits de la partie hôte à 1.

En reprenant l'exemple précédent (réseau `192.168.1.128/25`) :

```
Réseau    : 11000000.10101000.00000001.10000000
                                       ^
                                       |
                              Ce bit et les suivants = partie hôte

Broadcast : 11000000.10101000.00000001.11111111
           = 192.168.1.255
```

### 8.5 Calcul du nombre d'hôtes

**Formule** : 2^h - 2, ou h = nombre de bits de la partie hôte.

Pour /25 : h = 32 - 25 = 7 bits hôte.

```
Nombre d'hôtes = 2^7 - 2 = 128 - 2 = 126 hôtes utilisables
```

**Plage d'adresses utilisables** : de la première adresse après l'adresse réseau à la dernière avant le broadcast.

```
Réseau    : 192.168.1.128
Première  : 192.168.1.129
Dernière  : 192.168.1.254
Broadcast : 192.168.1.255
```

### 8.6 Tableau récapitulatif des masques courants

| CIDR | Masque | Nb de sous-réseaux (depuis /24) | Nb d'hôtes par sous-réseau | Taille du bloc |
|------|--------|--------------------------------|---------------------------|----------------|
| /24 | 255.255.255.0 | 1 | 254 | 256 |
| /25 | 255.255.255.128 | 2 | 126 | 128 |
| /26 | 255.255.255.192 | 4 | 62 | 64 |
| /27 | 255.255.255.224 | 8 | 30 | 32 |
| /28 | 255.255.255.240 | 16 | 14 | 16 |
| /29 | 255.255.255.248 | 32 | 6 | 8 |
| /30 | 255.255.255.252 | 64 | 2 | 4 |

---

## 9. Découpage en sous-réseaux (subnetting)

### 9.1 Pourquoi découper

- Réduire la taille des domaines de broadcast.
- Améliorer les performances réseau.
- Renforcer la sécurité (segmentation).
- Optimiser l'utilisation des adresses IP.
- Répondre à des contraintes organisationnelles (un sous-réseau par service, par étage, par site).

### 9.2 Méthode de subnetting

**Etape 1** : Déterminer le nombre de sous-réseaux nécessaires ou le nombre d'hôtes par sous-réseau.

**Etape 2** : Calculer le nombre de bits à emprunter à la partie hôte.
- Pour n sous-réseaux, il faut emprunter s bits tels que 2^s >= n.
- Pour h hôtes par sous-réseau, il faut garder assez de bits hôte tels que 2^h - 2 >= nombre d'hôtes requis.

**Etape 3** : Construire le nouveau masque.

**Etape 4** : Calculer la taille du bloc (2^bits_hôte_restants).

**Etape 5** : Lister les sous-réseaux avec leurs adresses réseau, plages et broadcast.

### 9.3 Exemple détaillé

**Enoncé** : Découper le réseau `192.168.10.0/24` en 4 sous-réseaux.

**Etape 1** : On veut 4 sous-réseaux.

**Etape 2** : Combien de bits emprunter ? 2^s >= 4, donc s = 2 bits.

**Etape 3** : Nouveau masque = /24 + 2 = /26.

```
Ancien masque : 11111111.11111111.11111111.00000000 = /24
Nouveau masque: 11111111.11111111.11111111.11000000 = /26
                                           ^^
                                           Bits empruntés
```

Masque en décimal : 255.255.255.192.

**Etape 4** : Bits hôte restants = 32 - 26 = 6. Taille du bloc = 2^6 = 64. Hôtes par sous-réseau = 64 - 2 = 62.

**Etape 5** : Liste des sous-réseaux :

| Sous-réseau | Adresse réseau | Première adresse | Dernière adresse | Broadcast |
|-------------|---------------|-----------------|-----------------|-----------|
| 1 | 192.168.10.0 | 192.168.10.1 | 192.168.10.62 | 192.168.10.63 |
| 2 | 192.168.10.64 | 192.168.10.65 | 192.168.10.126 | 192.168.10.127 |
| 3 | 192.168.10.128 | 192.168.10.129 | 192.168.10.190 | 192.168.10.191 |
| 4 | 192.168.10.192 | 192.168.10.193 | 192.168.10.254 | 192.168.10.255 |

**Vérification en binaire pour le sous-réseau 2** :

```
Adresse réseau : 192.168.10.01000000 = 192.168.10.64
Broadcast      : 192.168.10.01111111 = 192.168.10.127
                             ^^
                             Bits de sous-réseau = 01
                               ^^^^^^
                               Bits hôte (tous à 0 = réseau, tous à 1 = broadcast)
```

### 9.4 Subnetting avec contrainte de nombre d'hôtes

**Enoncé** : Le réseau `10.0.0.0/8`. On a besoin de sous-réseaux pouvant contenir 500 hôtes chacun.

**Etape 1** : 500 hôtes par sous-réseau.

**Etape 2** : Combien de bits hôte garder ? 2^h - 2 >= 500.
- 2^9 = 512, 512 - 2 = 510 >= 500. On garde 9 bits hôte.

**Etape 3** : Nouveau masque = 32 - 9 = /23.

```
Masque : 11111111.11111111.11111110.00000000 = 255.255.254.0
```

**Etape 4** : Taille du bloc = 2^9 = 512 adresses. Hôtes utilisables = 510.

**Etape 5** (premiers sous-réseaux) :

| Sous-réseau | Adresse réseau | Première | Dernière | Broadcast |
|-------------|---------------|----------|----------|-----------|
| 1 | 10.0.0.0 | 10.0.0.1 | 10.0.1.254 | 10.0.1.255 |
| 2 | 10.0.2.0 | 10.0.2.1 | 10.0.3.254 | 10.0.3.255 |
| 3 | 10.0.4.0 | 10.0.4.1 | 10.0.5.254 | 10.0.5.255 |

Nombre total de sous-réseaux possibles : 2^(23-8) = 2^15 = 32 768 sous-réseaux.

---

## 10. Protocole ARP

### 10.1 Rôle

ARP (Address Resolution Protocol, RFC 826) permet de trouver l'adresse MAC (couche 2) correspondant à une adresse IP (couche 3) connue, au sein d'un même réseau local.

Quand une machine veut envoyer un paquet IP à une autre machine sur le même réseau, elle connaît l'adresse IP destination mais pas l'adresse MAC. Or, la trame Ethernet nécessite une adresse MAC de destination. ARP résout ce problème.

### 10.2 Fonctionnement

1. **Vérification du cache ARP** : la machine source consulte sa table ARP locale. Si l'association IP/MAC est déjà connue, elle l'utilise directement.

2. **Requête ARP (ARP Request)** : si l'association est absente, la source envoie une trame de broadcast Ethernet (destination MAC : `FF:FF:FF:FF:FF:FF`) contenant :
   - "Qui a l'adresse IP x.x.x.x ? Dites-le à [IP source] / [MAC source]."

3. **Réponse ARP (ARP Reply)** : la machine qui possède l'adresse IP demandée répond en unicast :
   - "L'adresse IP x.x.x.x correspond à l'adresse MAC [sa MAC]."

4. **Mise à jour du cache** : la source enregistre l'association dans sa table ARP (durée de vie limitée, typiquement quelques minutes).

### 10.3 Table ARP

Consultation de la table ARP :
- Windows : `arp -a`
- Linux : `arp -n` ou `ip neigh show`

Exemple de table ARP :

```
Adresse IP        Adresse MAC           Type
192.168.1.1       aa:bb:cc:dd:ee:01     dynamique
192.168.1.20      aa:bb:cc:dd:ee:14     dynamique
```

### 10.4 Sécurité : ARP Spoofing

ARP ne possède aucun mécanisme d'authentification. Une machine malveillante peut envoyer de fausses réponses ARP pour intercepter le trafic (attaque Man-in-the-Middle). Contre-mesures : ARP statique, Dynamic ARP Inspection (DAI) sur les switchs managés, 802.1X.

---

## 11. Protocole ICMP

### 11.1 Rôle

ICMP (Internet Control Message Protocol, RFC 792) est un protocole de couche 3 utilisé pour envoyer des messages d'erreur et des informations de diagnostic. Il est encapsulé directement dans des paquets IP (protocole numéro 1).

### 11.2 Messages ICMP courants

| Type | Code | Description |
|------|------|-------------|
| 0 | 0 | Echo Reply (réponse au ping) |
| 3 | 0 | Destination Unreachable -- Network Unreachable |
| 3 | 1 | Destination Unreachable -- Host Unreachable |
| 3 | 3 | Destination Unreachable -- Port Unreachable |
| 4 | 0 | Source Quench (obsolète) |
| 5 | 0 | Redirect |
| 8 | 0 | Echo Request (ping) |
| 11 | 0 | Time Exceeded -- TTL expiré (utilisé par traceroute) |

### 11.3 Commande ping

La commande `ping` envoie des paquets ICMP Echo Request à une destination et attend des ICMP Echo Reply. Elle permet de :
- Vérifier la connectivité réseau.
- Mesurer le temps d'aller-retour (RTT -- Round Trip Time).
- Détecter la perte de paquets.

```
ping 192.168.1.1
```

### 11.4 Commande traceroute (tracert sous Windows)

Traceroute envoie des paquets avec un TTL (Time To Live) croissant (1, 2, 3, ...). Chaque routeur traversé décrémente le TTL de 1. Quand le TTL atteint 0, le routeur renvoie un message ICMP "Time Exceeded" (type 11). Cela permet de découvrir chaque routeur intermédiaire sur le chemin.

```
traceroute 8.8.8.8       (Linux/Mac)
tracert 8.8.8.8           (Windows)
```

---

## 12. DNS (Domain Name System)

### 12.1 Rôle

Le DNS traduit les noms de domaine lisibles par l'homme (ex. : `www.example.com`) en adresses IP utilisables par les machines (ex. : `93.184.216.34`). Sans le DNS, il faudrait mémoriser les adresses IP de chaque site.

### 12.2 Hiérarchie DNS

Le DNS est organisé en arborescence :

```
                    . (racine)
                   / | \
                 com  fr  org  net  ...
                / |     |
           google  example   gouv
           /    \
         www   mail
```

**Niveaux** :
- **Racine (root)** : sommet de l'arborescence, représenté par un point (`.`). Géré par 13 groupes de serveurs racine (A à M).
- **TLD (Top-Level Domain)** : `.com`, `.fr`, `.org`, `.net`, `.edu`, etc.
- **Domaine de second niveau** : `example.com`, `google.fr`.
- **Sous-domaine** : `mail.google.com`, `www.example.com`.
- **FQDN** (Fully Qualified Domain Name) : nom complet terminé par un point : `www.example.com.`

### 12.3 Résolution de nom (processus)

Quand un utilisateur tape `www.example.com` dans son navigateur :

1. **Cache local** : le système vérifie son cache DNS et le fichier `hosts`.
2. **Requête au résolveur récursif** (serveur DNS configuré, souvent celui du FAI ou un public comme `8.8.8.8`).
3. Le résolveur interroge un **serveur racine** qui répond : "Je ne connais pas, mais demande aux serveurs de `.com`."
4. Le résolveur interroge le **serveur TLD `.com`** qui répond : "Je ne connais pas, mais demande au serveur autoritaire de `example.com`."
5. Le résolveur interroge le **serveur autoritaire** de `example.com` qui répond avec l'adresse IP.
6. Le résolveur renvoie la réponse au client et la met en cache (selon le TTL).

### 12.4 Types d'enregistrements DNS

| Type | Nom | Description | Exemple |
|------|-----|-------------|---------|
| A | Address | Associe un nom à une adresse IPv4 | `www IN A 93.184.216.34` |
| AAAA | IPv6 Address | Associe un nom à une adresse IPv6 | `www IN AAAA 2606:2800:220:1:...` |
| CNAME | Canonical Name | Alias pointant vers un autre nom | `blog IN CNAME www.example.com.` |
| MX | Mail Exchanger | Serveur de messagerie du domaine (avec priorité) | `@ IN MX 10 mail.example.com.` |
| NS | Name Server | Serveur DNS autoritaire pour la zone | `@ IN NS ns1.example.com.` |
| PTR | Pointer | Résolution inverse (IP vers nom) | `34 IN PTR www.example.com.` |
| SOA | Start of Authority | Informations sur la zone (serveur primaire, contact, numéro de série, timers) | (voir ci-dessous) |
| TXT | Text | Texte libre, utilisé pour SPF, DKIM, vérification de domaine | `@ IN TXT "v=spf1 mx -all"` |
| SRV | Service | Localisation de services (port, priorité, poids) | `_sip._tcp IN SRV 10 60 5060 sip.example.com.` |

**Exemple d'enregistrement SOA** :

```
@ IN SOA ns1.example.com. admin.example.com. (
    2024011501  ; Numéro de série
    3600        ; Refresh (1h)
    900         ; Retry (15min)
    1209600     ; Expire (14j)
    86400       ; TTL minimum (1j)
)
```

### 12.5 Commandes de diagnostic DNS

- `nslookup www.example.com` : requête DNS simple.
- `dig www.example.com` (Linux) : requête détaillée.
- `dig -x 93.184.216.34` : résolution inverse (PTR).

---

## 13. DHCP (Dynamic Host Configuration Protocol)

### 13.1 Rôle

Le DHCP attribue automatiquement une configuration IP complète aux clients : adresse IP, masque de sous-réseau, passerelle par défaut, serveurs DNS, et d'autres options.

### 13.2 Fonctionnement DORA

Le processus d'obtention d'une adresse IP par DHCP se déroule en 4 étapes, appelées DORA :

**1. Discover (Découverte)**
- Le client envoie un message DHCP Discover en **broadcast** (destination IP : 255.255.255.255, destination MAC : FF:FF:FF:FF:FF:FF).
- Source IP : 0.0.0.0 (le client n'a pas encore d'adresse).
- Protocole : UDP, port source 68 (client), port destination 67 (serveur).
- Message : "Y a-t-il un serveur DHCP sur ce réseau ?"

**2. Offer (Offre)**
- Le serveur DHCP répond avec un DHCP Offer contenant une proposition d'adresse IP et les paramètres réseau.
- Envoyé en broadcast (ou unicast selon l'implémentation).
- Message : "Je te propose l'adresse 192.168.1.50 avec le masque /24, la passerelle 192.168.1.1 et le DNS 8.8.8.8."

**3. Request (Requête)**
- Le client accepte l'offre en envoyant un DHCP Request en **broadcast** (pour informer tous les serveurs DHCP du réseau de son choix).
- Message : "J'accepte l'adresse 192.168.1.50 proposée par le serveur 192.168.1.1."

**4. Acknowledge (Accusé de réception)**
- Le serveur confirme l'attribution avec un DHCP Acknowledge.
- Le client configure son interface réseau avec les paramètres reçus.

### 13.3 Bail DHCP (lease)

L'adresse IP est attribuée pour une durée limitée appelée **bail** (lease). A mi-bail, le client tente de renouveler son adresse auprès du même serveur. Si le renouvellement échoue, il tente de nouveau à 87,5 % du bail. Si le bail expire, le client doit recommencer le processus DORA.

### 13.4 Réservation DHCP

L'administrateur peut configurer le serveur DHCP pour attribuer toujours la même adresse IP à une machine, en associant son adresse MAC à une adresse IP fixe. Cela combine l'avantage de la configuration centralisée (DHCP) avec la stabilité d'une adresse fixe (utile pour les serveurs, imprimantes).

### 13.5 Relais DHCP (DHCP Relay)

Les messages DHCP étant envoyés en broadcast, ils ne franchissent pas les routeurs. Si le serveur DHCP se trouve sur un autre sous-réseau, un agent relais DHCP (souvent configuré sur le routeur) intercepte les Discover et les transmet en unicast au serveur DHCP.

---

## 14. TCP vs UDP

### 14.1 TCP (Transmission Control Protocol)

TCP est un protocole de couche 4 **orienté connexion** et **fiable**.

**Caractéristiques** :
- Etablissement de connexion (three-way handshake).
- Fiabilité : accusés de réception (ACK), retransmission des segments perdus.
- Contrôle de flux : fenêtre glissante (sliding window).
- Contrôle de congestion : algorithmes (slow start, congestion avoidance).
- Remise en ordre des segments (numéros de séquence).
- Full-duplex.

**Three-way handshake (poignée de main en 3 temps)** :

```
Client                         Serveur
  |                               |
  |---- SYN (seq=x) ------------>|    1. Le client demande une connexion
  |                               |
  |<--- SYN-ACK (seq=y, ack=x+1)-|    2. Le serveur accepte et demande confirmation
  |                               |
  |---- ACK (seq=x+1, ack=y+1) ->|    3. Le client confirme
  |                               |
  |      Connexion établie        |
```

**Fermeture de connexion (four-way handshake)** :

```
Client                         Serveur
  |                               |
  |---- FIN ---------------------->|   1. Le client veut fermer
  |<--- ACK -----------------------|   2. Le serveur accuse réception
  |<--- FIN -----------------------|   3. Le serveur veut aussi fermer
  |---- ACK ---------------------->|   4. Le client confirme
  |                               |
  |      Connexion fermée         |
```

**En-tête TCP** (20 octets minimum) :
- Port source (16 bits)
- Port destination (16 bits)
- Numéro de séquence (32 bits)
- Numéro d'accusé de réception (32 bits)
- Longueur de l'en-tête (4 bits)
- Drapeaux : URG, ACK, PSH, RST, SYN, FIN (6 bits)
- Taille de fenêtre (16 bits)
- Checksum (16 bits)
- Pointeur urgent (16 bits)

### 14.2 UDP (User Datagram Protocol)

UDP est un protocole de couche 4 **sans connexion** et **non fiable**.

**Caractéristiques** :
- Pas d'établissement de connexion.
- Pas de garantie de livraison, pas de retransmission.
- Pas de contrôle de flux ni de congestion.
- Pas de remise en ordre.
- En-tête minimal (8 octets) : port source, port destination, longueur, checksum.
- Rapide et léger.

**Usages** : applications temps réel (VoIP, streaming vidéo, jeux en ligne), DNS (requêtes simples), DHCP, TFTP, SNMP.

### 14.3 Comparaison TCP vs UDP

| Critère | TCP | UDP |
|---------|-----|-----|
| Connexion | Orienté connexion | Sans connexion |
| Fiabilité | Fiable (ACK, retransmission) | Non fiable |
| Ordre | Garanti | Non garanti |
| Contrôle de flux | Oui | Non |
| Overhead | Elevé (en-tête 20+ octets) | Faible (en-tête 8 octets) |
| Vitesse | Plus lent | Plus rapide |
| Usage | Web, mail, transfert de fichiers | Streaming, VoIP, DNS, jeux |

### 14.4 Numéros de port courants

| Port | Protocole | Service |
|------|-----------|---------|
| 20 | TCP | FTP (données) |
| 21 | TCP | FTP (contrôle) |
| 22 | TCP | SSH |
| 23 | TCP | Telnet |
| 25 | TCP | SMTP |
| 53 | TCP/UDP | DNS |
| 67 | UDP | DHCP (serveur) |
| 68 | UDP | DHCP (client) |
| 69 | UDP | TFTP |
| 80 | TCP | HTTP |
| 110 | TCP | POP3 |
| 143 | TCP | IMAP |
| 161 | UDP | SNMP |
| 443 | TCP | HTTPS |
| 445 | TCP | SMB |
| 3389 | TCP | RDP (Bureau à distance) |

**Classification des ports** :
- **Ports bien connus** (Well-known) : 0 à 1023. Réservés aux services standards.
- **Ports enregistrés** (Registered) : 1024 à 49151. Utilisés par des applications spécifiques.
- **Ports dynamiques/privés** : 49152 à 65535. Attribués temporairement aux clients.

---

## 15. NAT et PAT

### 15.1 Pourquoi la NAT

Les adresses IPv4 publiques sont en nombre limité (environ 4,3 milliards). Les adresses privées (RFC 1918) ne sont pas routables sur Internet. La NAT (Network Address Translation) permet à plusieurs machines d'un réseau privé de partager une ou plusieurs adresses IP publiques pour accéder à Internet.

### 15.2 NAT statique

Association permanente d'une adresse privée à une adresse publique (one-to-one). Utilisée pour rendre un serveur interne accessible depuis Internet.

```
Réseau interne            Routeur NAT            Internet
192.168.1.10  ←→  Translation  ←→  203.0.113.10
```

### 15.3 NAT dynamique

Un pool d'adresses publiques est partagé entre les machines internes. L'association est temporaire et attribuée à la demande (many-to-many, mais le pool est limité).

### 15.4 PAT (Port Address Translation) / NAT overload

Aussi appelée **NAPT** (Network Address Port Translation). C'est la forme la plus courante de NAT. Plusieurs machines internes partagent une **seule** adresse publique. Le routeur différencie les connexions grâce aux numéros de port source.

**Exemple** :

```
Réseau interne                    Routeur (PAT)                  Internet

192.168.1.10:45000  →  203.0.113.1:50001  →  Serveur 8.8.8.8:53
192.168.1.20:45000  →  203.0.113.1:50002  →  Serveur 8.8.8.8:53
192.168.1.30:52000  →  203.0.113.1:50003  →  Serveur 93.184.216.34:80
```

Le routeur maintient une table de traduction NAT pour associer chaque flux interne à un port source unique côté public.

### 15.5 Limites de la NAT

- Complexifie les protocoles qui intègrent l'adresse IP dans les données (FTP actif, SIP, IPsec).
- Rompt le principe de bout en bout d'Internet.
- Rend difficile l'hébergement de services derrière le NAT (nécessite la redirection de ports).
- Ajoute de la latence (traitement supplémentaire).

---

## 16. IPv6

### 16.1 Pourquoi IPv6

IPv4 offre environ 4,3 milliards d'adresses (2^32). Avec la croissance d'Internet et des objets connectés, les adresses sont épuisées (les derniers blocs /8 ont été attribués par l'IANA en 2011). IPv6 résout ce problème avec un espace d'adressage immensément plus grand.

### 16.2 Format d'une adresse IPv6

- **128 bits** (contre 32 pour IPv4).
- Notée en **8 groupes de 4 chiffres hexadécimaux**, séparés par des deux-points.
- Nombre d'adresses : 2^128 = environ 3,4 x 10^38.

Exemple complet :

```
2001:0db8:0000:0000:0000:0000:0000:0001
```

### 16.3 Notation abrégée

**Règle 1** : les zéros en tête de chaque groupe peuvent être omis.

```
2001:0db8:0000:0000:0000:0000:0000:0001
→ 2001:db8:0:0:0:0:0:1
```

**Règle 2** : une seule suite consécutive de groupes entièrement à zéro peut être remplacée par `::`.

```
2001:db8:0:0:0:0:0:1
→ 2001:db8::1
```

**Attention** : `::` ne peut apparaître qu'une seule fois dans une adresse, sinon l'ambiguïté serait impossible à résoudre.

Autres exemples :

```
fe80:0000:0000:0000:0000:0000:0000:0001 → fe80::1
0000:0000:0000:0000:0000:0000:0000:0001 → ::1 (loopback)
0000:0000:0000:0000:0000:0000:0000:0000 → :: (adresse non spécifiée)
2001:0db8:abcd:0012:0000:0000:0000:0000 → 2001:db8:abcd:12::
```

### 16.4 Structure d'une adresse IPv6

Typiquement, une adresse IPv6 se divise en :
- **Préfixe réseau** : les 64 premiers bits (identifient le réseau).
- **Identifiant d'interface** : les 64 derniers bits (identifient l'hôte, souvent dérivé de l'adresse MAC via EUI-64 ou généré aléatoirement).

Le préfixe est noté avec la longueur, comme en CIDR : `2001:db8:abcd:12::/64`.

### 16.5 Types d'adresses IPv6

| Type | Préfixe | Description |
|------|---------|-------------|
| Unicast global (GUA) | 2000::/3 | Equivalent des adresses publiques IPv4. Routable sur Internet. |
| Link-local | fe80::/10 | Adresse automatique, valable uniquement sur le lien local (comme APIPA). Non routable. Obligatoire sur chaque interface. |
| Unique local (ULA) | fc00::/7 (en pratique fd00::/8) | Equivalent des adresses privées IPv4. Non routable sur Internet. |
| Multicast | ff00::/8 | Remplacement du broadcast (qui n'existe plus en IPv6). |
| Loopback | ::1 | Equivalent de 127.0.0.1. |
| Non spécifiée | :: | Equivalent de 0.0.0.0. |

**Note importante** : IPv6 n'a plus de broadcast. Il utilise le multicast pour les fonctions équivalentes (ex. : `ff02::1` = tous les noeuds du lien).

### 16.6 Mécanismes de transition IPv4 vers IPv6

- **Double pile (dual stack)** : chaque équipement gère simultanément IPv4 et IPv6. Méthode la plus courante.
- **Tunneling** : encapsuler des paquets IPv6 dans des paquets IPv4 pour traverser des réseaux IPv4 (6to4, Teredo, ISATAP).
- **Translation (NAT64/DNS64)** : traduire les paquets entre IPv4 et IPv6 pour permettre la communication entre les deux mondes.

### 16.7 Autres différences avec IPv4

| Caractéristique | IPv4 | IPv6 |
|-----------------|------|------|
| Taille d'adresse | 32 bits | 128 bits |
| Notation | Décimale pointée | Hexadécimale avec deux-points |
| Configuration | Manuelle ou DHCP | Auto-configuration (SLAAC) + DHCPv6 |
| Fragmentation | Par les routeurs | Uniquement par la source |
| En-tête | Variable (20-60 octets) | Fixe (40 octets) + extensions |
| Broadcast | Oui | Non (remplacé par multicast) |
| ARP | Oui | Non (remplacé par NDP -- Neighbor Discovery Protocol) |
| IPsec | Optionnel | Intégré nativement (mais optionnel en pratique) |
| Checksum IP | Oui | Non (délégué aux couches supérieures) |

---

## 17. Exercices corrigés

### Exercice 1 -- Conversion décimal vers binaire

**Enoncé** : Convertir l'adresse `172.16.254.1` en binaire.

**Correction** :

```
172 = 128 + 32 + 8 + 4 = 10101100
  172 / 2 = 86  reste 0
   86 / 2 = 43  reste 0
   43 / 2 = 21  reste 1
   21 / 2 = 10  reste 1
   10 / 2 = 5   reste 0
    5 / 2 = 2   reste 1
    2 / 2 = 1   reste 0
    1 / 2 = 0   reste 1
  Lecture de bas en haut : 10101100

16 = 00010000
  16 / 2 = 8  reste 0
   8 / 2 = 4  reste 0
   4 / 2 = 2  reste 0
   2 / 2 = 1  reste 0
   1 / 2 = 0  reste 1
  Compléter à 8 bits : 00010000

254 = 11111110
  254 / 2 = 127  reste 0
  127 / 2 = 63   reste 1
   63 / 2 = 31   reste 1
   31 / 2 = 15   reste 1
   15 / 2 = 7    reste 1
    7 / 2 = 3    reste 1
    3 / 2 = 1    reste 1
    1 / 2 = 0    reste 1
  Lecture de bas en haut : 11111110

1 = 00000001

Résultat : 10101100.00010000.11111110.00000001
```

---

### Exercice 2 -- Identification de la classe et du type d'adresse

**Enoncé** : Pour chaque adresse, indiquer la classe et si elle est publique, privée ou spéciale.

1. `10.0.0.1`
2. `172.20.5.3`
3. `192.168.0.100`
4. `8.8.8.8`
5. `127.0.0.1`
6. `169.254.10.5`
7. `224.0.0.1`
8. `192.0.2.1`

**Correction** :

| Adresse | Classe | Type |
|---------|--------|------|
| `10.0.0.1` | A (1er octet = 10) | Privée (RFC 1918 : 10.0.0.0/8) |
| `172.20.5.3` | B (1er octet = 172) | Privée (RFC 1918 : 172.16.0.0/12, car 16 <= 20 <= 31) |
| `192.168.0.100` | C (1er octet = 192) | Privée (RFC 1918 : 192.168.0.0/16) |
| `8.8.8.8` | A (1er octet = 8) | Publique (serveur DNS de Google) |
| `127.0.0.1` | A (1er octet = 127) | Spéciale -- Loopback |
| `169.254.10.5` | B (1er octet = 169) | Spéciale -- APIPA |
| `224.0.0.1` | D (1er octet = 224) | Multicast |
| `192.0.2.1` | C (1er octet = 192) | Spéciale -- Documentation (RFC 5737) |

---

### Exercice 3 -- Calcul d'adresse réseau et broadcast

**Enoncé** : Trouver l'adresse réseau, le broadcast, la première et la dernière adresse utilisable pour `10.45.200.67/20`.

**Correction** :

Etape 1 -- Convertir en binaire :

```
IP     : 10.45.200.67
       = 00001010.00101101.11001000.01000011

Masque /20 :
       = 11111111.11111111.11110000.00000000
       = 255.255.240.0
```

Etape 2 -- ET logique pour l'adresse réseau :

```
IP     : 00001010.00101101.11001000.01000011
Masque : 11111111.11111111.11110000.00000000
         ────────────────────────────────────
Réseau : 00001010.00101101.11000000.00000000
       = 10.45.192.0
```

Détail du 3e octet :

```
IP     : 11001000  (200)
Masque : 11110000  (240)
AND    : 11000000  (192)
```

Etape 3 -- Broadcast (tous les bits hôte à 1) :

```
Réseau    : 00001010.00101101.11000000.00000000
Broadcast : 00001010.00101101.11001111.11111111
          = 10.45.207.255
```

Etape 4 -- Nombre d'hôtes :

```
Bits hôte = 32 - 20 = 12
Nombre d'hôtes = 2^12 - 2 = 4096 - 2 = 4094
```

Etape 5 -- Plage :

```
Adresse réseau    : 10.45.192.0
Première adresse  : 10.45.192.1
Dernière adresse  : 10.45.207.254
Broadcast         : 10.45.207.255
```

---

### Exercice 4 -- Subnetting : découper en 8 sous-réseaux

**Enoncé** : Découper `172.16.0.0/16` en 8 sous-réseaux. Donner le masque, le nombre d'hôtes par sous-réseau, et les 3 premiers sous-réseaux en détail.

**Correction** :

Bits à emprunter : 2^s >= 8, donc s = 3 bits.

Nouveau masque : /16 + 3 = /19.

```
Masque /19 : 11111111.11111111.11100000.00000000
           = 255.255.224.0
```

Bits hôte restants : 32 - 19 = 13.
Hôtes par sous-réseau : 2^13 - 2 = 8192 - 2 = 8190.
Taille du bloc : 2^13 = 8192 adresses = 32 dans le 3e octet (car 2^5 = 32, les 5 bits de poids faible du 3e octet + 8 bits du 4e octet = 13 bits).

Vérification : le 3e octet des sous-réseaux avance par pas de 32 (2^5, les 5 bits restants dans le 3e octet).

| # | Adresse réseau | Première | Dernière | Broadcast |
|---|---------------|----------|----------|-----------|
| 1 | 172.16.0.0/19 | 172.16.0.1 | 172.16.31.254 | 172.16.31.255 |
| 2 | 172.16.32.0/19 | 172.16.32.1 | 172.16.63.254 | 172.16.63.255 |
| 3 | 172.16.64.0/19 | 172.16.64.1 | 172.16.95.254 | 172.16.95.255 |
| 4 | 172.16.96.0/19 | 172.16.96.1 | 172.16.127.254 | 172.16.127.255 |
| 5 | 172.16.128.0/19 | 172.16.128.1 | 172.16.159.254 | 172.16.159.255 |
| 6 | 172.16.160.0/19 | 172.16.160.1 | 172.16.191.254 | 172.16.191.255 |
| 7 | 172.16.192.0/19 | 172.16.192.1 | 172.16.223.254 | 172.16.223.255 |
| 8 | 172.16.224.0/19 | 172.16.224.1 | 172.16.255.254 | 172.16.255.255 |

Vérification en binaire pour le sous-réseau 3 :

```
Réseau : 172.16.01000000.00000000 = 172.16.64.0
                ^^^
                Bits empruntés = 010 (3e sous-réseau, comptage à partir de 000)
```

```
Broadcast : 172.16.01011111.11111111 = 172.16.95.255
                   ^^^
                   Bits empruntés = 010
                      ^^^^^.^^^^^^^^
                      Bits hôte tous à 1
```

---

### Exercice 5 -- Subnetting avec contrainte d'hôtes

**Enoncé** : A partir du réseau `192.168.5.0/24`, créer des sous-réseaux contenant au maximum 25 hôtes chacun. Combien de sous-réseaux obtiendra-t-on ?

**Correction** :

Bits hôte nécessaires : 2^h - 2 >= 25.
- 2^4 = 16, 16 - 2 = 14 : insuffisant.
- 2^5 = 32, 32 - 2 = 30 : suffisant. On garde 5 bits hôte.

Nouveau masque : 32 - 5 = /27.

```
Masque /27 : 11111111.11111111.11111111.11100000
           = 255.255.255.224
```

Bits empruntés depuis /24 : 27 - 24 = 3 bits.
Nombre de sous-réseaux : 2^3 = 8.
Hôtes par sous-réseau : 2^5 - 2 = 30.
Taille du bloc : 2^5 = 32.

| # | Adresse réseau | Première | Dernière | Broadcast |
|---|---------------|----------|----------|-----------|
| 1 | 192.168.5.0/27 | 192.168.5.1 | 192.168.5.30 | 192.168.5.31 |
| 2 | 192.168.5.32/27 | 192.168.5.33 | 192.168.5.62 | 192.168.5.63 |
| 3 | 192.168.5.64/27 | 192.168.5.65 | 192.168.5.94 | 192.168.5.95 |
| 4 | 192.168.5.96/27 | 192.168.5.97 | 192.168.5.126 | 192.168.5.127 |
| 5 | 192.168.5.128/27 | 192.168.5.129 | 192.168.5.158 | 192.168.5.159 |
| 6 | 192.168.5.160/27 | 192.168.5.161 | 192.168.5.190 | 192.168.5.191 |
| 7 | 192.168.5.192/27 | 192.168.5.193 | 192.168.5.222 | 192.168.5.223 |
| 8 | 192.168.5.224/27 | 192.168.5.225 | 192.168.5.254 | 192.168.5.255 |

---

### Exercice 6 -- Adresse réseau avec masque non standard

**Enoncé** : L'adresse `192.168.100.200/28`. Calculer l'adresse réseau, le broadcast, la plage utilisable.

**Correction** :

```
Masque /28 : 11111111.11111111.11111111.11110000
           = 255.255.255.240
```

Conversion du dernier octet de l'IP :

```
200 = 11001000
```

ET logique avec le masque (dernier octet) :

```
IP     : 11001000  (200)
Masque : 11110000  (240)
AND    : 11000000  (192)
```

```
Adresse réseau : 192.168.100.192
```

Broadcast (bits hôte à 1) :

```
Réseau    : 192.168.100.11000000
Broadcast : 192.168.100.11001111 = 192.168.100.207
```

Nombre d'hôtes : 2^4 - 2 = 14.

```
Adresse réseau    : 192.168.100.192
Première adresse  : 192.168.100.193
Dernière adresse  : 192.168.100.206
Broadcast         : 192.168.100.207
```

---

### Exercice 7 -- Deux machines sont-elles sur le même réseau ?

**Enoncé** : La machine A a l'adresse `192.168.1.130/25`. La machine B a l'adresse `192.168.1.200/25`. Sont-elles sur le même réseau ?

**Correction** :

Calculons l'adresse réseau de chaque machine.

Masque /25 : 255.255.255.128 = `11111111.11111111.11111111.10000000`

Machine A : `192.168.1.130`

```
130 = 10000010
Masque dernier octet : 10000000
AND : 10000000 = 128
Adresse réseau A : 192.168.1.128
```

Machine B : `192.168.1.200`

```
200 = 11001000
Masque dernier octet : 10000000
AND : 10000000 = 128
Adresse réseau B : 192.168.1.128
```

Les deux adresses réseau sont identiques (192.168.1.128). **Oui, les machines A et B sont sur le même réseau.**

---

### Exercice 8 -- Deux machines sur des réseaux différents

**Enoncé** : Machine C = `192.168.1.100/26`, Machine D = `192.168.1.200/26`. Même réseau ?

**Correction** :

Masque /26 : 255.255.255.192 = `11111111.11111111.11111111.11000000`

Machine C : dernier octet = 100

```
100 = 01100100
Masque : 11000000
AND   : 01000000 = 64
Réseau C : 192.168.1.64
```

Machine D : dernier octet = 200

```
200 = 11001000
Masque : 11000000
AND   : 11000000 = 192
Réseau D : 192.168.1.192
```

Les adresses réseau sont différentes (64 vs 192). **Non, les machines C et D ne sont pas sur le même réseau.** Elles ont besoin d'un routeur pour communiquer.

---

### Exercice 9 -- VLSM (Variable Length Subnet Masking)

**Enoncé** : A partir du réseau `192.168.50.0/24`, créer des sous-réseaux pour les besoins suivants :
- LAN A : 100 hôtes
- LAN B : 50 hôtes
- LAN C : 25 hôtes
- LAN D : 10 hôtes
- Liaison WAN : 2 hôtes

**Correction** :

Avec VLSM, on alloue des masques de taille variable. On commence par le plus grand besoin.

**LAN A -- 100 hôtes** :
- 2^h - 2 >= 100 → 2^7 = 128, 128 - 2 = 126 >= 100. On garde 7 bits hôte → /25.
- Sous-réseau : 192.168.50.0/25
- Plage : 192.168.50.1 -- 192.168.50.126
- Broadcast : 192.168.50.127
- 126 hôtes disponibles.

**LAN B -- 50 hôtes** :
- 2^6 = 64, 64 - 2 = 62 >= 50. On garde 6 bits → /26.
- Sous-réseau : 192.168.50.128/26 (suite après le bloc précédent)
- Plage : 192.168.50.129 -- 192.168.50.190
- Broadcast : 192.168.50.191
- 62 hôtes disponibles.

**LAN C -- 25 hôtes** :
- 2^5 = 32, 32 - 2 = 30 >= 25. On garde 5 bits → /27.
- Sous-réseau : 192.168.50.192/27
- Plage : 192.168.50.193 -- 192.168.50.222
- Broadcast : 192.168.50.223
- 30 hôtes disponibles.

**LAN D -- 10 hôtes** :
- 2^4 = 16, 16 - 2 = 14 >= 10. On garde 4 bits → /28.
- Sous-réseau : 192.168.50.224/28
- Plage : 192.168.50.225 -- 192.168.50.238
- Broadcast : 192.168.50.239
- 14 hôtes disponibles.

**Liaison WAN -- 2 hôtes** :
- 2^2 = 4, 4 - 2 = 2 >= 2. On garde 2 bits → /30.
- Sous-réseau : 192.168.50.240/30
- Plage : 192.168.50.241 -- 192.168.50.242
- Broadcast : 192.168.50.243
- 2 hôtes disponibles.

**Récapitulatif** :

| Réseau | Besoin | Masque | Adresse réseau | Plage | Broadcast | Hôtes dispo |
|--------|--------|--------|---------------|-------|-----------|-------------|
| LAN A | 100 | /25 | 192.168.50.0 | .1 -- .126 | .127 | 126 |
| LAN B | 50 | /26 | 192.168.50.128 | .129 -- .190 | .191 | 62 |
| LAN C | 25 | /27 | 192.168.50.192 | .193 -- .222 | .223 | 30 |
| LAN D | 10 | /28 | 192.168.50.224 | .225 -- .238 | .239 | 14 |
| WAN | 2 | /30 | 192.168.50.240 | .241 -- .242 | .243 | 2 |

Adresses restantes non utilisées : 192.168.50.244 à 192.168.50.255 (12 adresses).

---

### Exercice 10 -- Identifier le masque à partir du nombre d'hôtes

**Enoncé** : Quel masque utiliser pour un sous-réseau devant accueillir exactement 500 hôtes ?

**Correction** :

On cherche h tel que 2^h - 2 >= 500.

```
2^8  = 256   → 256 - 2 = 254    Insuffisant
2^9  = 512   → 512 - 2 = 510    Suffisant
```

On garde 9 bits pour la partie hôte.
Masque = 32 - 9 = /23.

```
/23 = 11111111.11111111.11111110.00000000
    = 255.255.254.0
```

On obtient 510 adresses utilisables, ce qui couvre le besoin de 500 hôtes.

---

### Exercice 11 -- Analyse d'une trame Ethernet

**Enoncé** : On capture la trame suivante (en hexadécimal, simplifiée) :

```
Dest MAC   : FF:FF:FF:FF:FF:FF
Source MAC  : AA:BB:CC:11:22:33
EtherType  : 08 06
```

Questions :
1. A quel type de destination cette trame est-elle envoyée ?
2. Quel protocole de couche supérieure est transporté ?
3. Pourquoi ce protocole utilise-t-il le broadcast ?

**Correction** :

1. L'adresse destination `FF:FF:FF:FF:FF:FF` est l'adresse de **broadcast Ethernet**. La trame est envoyée à toutes les machines du réseau local.

2. Le champ EtherType `0x0806` correspond au protocole **ARP** (Address Resolution Protocol).

3. ARP utilise le broadcast car la machine source ne connaît pas l'adresse MAC de la destination. Elle doit donc demander à toutes les machines du réseau "Qui possède cette adresse IP ?". Seule la machine concernée répondra (en unicast).

---

### Exercice 12 -- Processus DHCP

**Enoncé** : Décrire les 4 trames échangées lors de l'obtention d'une adresse IP par DHCP. Préciser pour chacune : le type de message, les adresses IP source et destination, les adresses MAC source et destination, les ports UDP.

**Correction** :

| Etape | Message | IP Source | IP Dest | MAC Source | MAC Dest | Port Src | Port Dst |
|-------|---------|-----------|---------|------------|----------|----------|----------|
| 1 | DHCP Discover | 0.0.0.0 | 255.255.255.255 | MAC client | FF:FF:FF:FF:FF:FF | 68 | 67 |
| 2 | DHCP Offer | IP serveur | 255.255.255.255 | MAC serveur | FF:FF:FF:FF:FF:FF | 67 | 68 |
| 3 | DHCP Request | 0.0.0.0 | 255.255.255.255 | MAC client | FF:FF:FF:FF:FF:FF | 68 | 67 |
| 4 | DHCP Ack | IP serveur | 255.255.255.255 | MAC serveur | FF:FF:FF:FF:FF:FF | 67 | 68 |

Note : certaines implémentations utilisent l'unicast pour le Offer et le Ack, en utilisant l'adresse IP proposée au client. Le broadcast reste le comportement standard décrit dans la RFC 2131.

---

### Exercice 13 -- TCP : analyse du three-way handshake

**Enoncé** : Un client (192.168.1.10, port 50000) se connecte à un serveur web (93.184.216.34, port 443). Décrire les 3 segments TCP échangés avec les drapeaux, numéros de séquence et d'acquittement.

**Correction** :

```
Segment 1 : Client → Serveur
  IP source      : 192.168.1.10
  IP destination : 93.184.216.34
  Port source    : 50000
  Port destination: 443
  Drapeau        : SYN
  Seq            : 1000 (exemple, choisi aléatoirement par le client)
  Ack            : 0

Segment 2 : Serveur → Client
  IP source      : 93.184.216.34
  IP destination : 192.168.1.10
  Port source    : 443
  Port destination: 50000
  Drapeaux       : SYN + ACK
  Seq            : 5000 (exemple, choisi aléatoirement par le serveur)
  Ack            : 1001 (= Seq client + 1)

Segment 3 : Client → Serveur
  IP source      : 192.168.1.10
  IP destination : 93.184.216.34
  Port source    : 50000
  Port destination: 443
  Drapeau        : ACK
  Seq            : 1001
  Ack            : 5001 (= Seq serveur + 1)

La connexion TCP est maintenant établie. Les données peuvent être échangées.
```

---

### Exercice 14 -- NAT/PAT

**Enoncé** : Un réseau interne utilise le réseau `192.168.1.0/24`. Le routeur possède l'adresse publique `203.0.113.5`. Trois machines internes accèdent simultanément à Internet. Compléter la table NAT/PAT.

| Machine interne | Port source interne | IP publique | Port source externe | Destination |
|-----------------|--------------------|----|-----|-----|
| 192.168.1.10 | 45000 | ? | ? | 8.8.8.8:53 |
| 192.168.1.20 | 45000 | ? | ? | 8.8.8.8:53 |
| 192.168.1.30 | 52000 | ? | ? | 93.184.216.34:80 |

**Correction** :

| Machine interne | Port source interne | IP publique | Port source externe | Destination |
|-----------------|--------------------|----|-----|-----|
| 192.168.1.10 | 45000 | 203.0.113.5 | 60001 | 8.8.8.8:53 |
| 192.168.1.20 | 45000 | 203.0.113.5 | 60002 | 8.8.8.8:53 |
| 192.168.1.30 | 52000 | 203.0.113.5 | 60003 | 93.184.216.34:80 |

Les trois machines partagent la même adresse IP publique (`203.0.113.5`). Le routeur attribue un port source externe unique à chaque flux pour pouvoir rediriger les réponses vers la bonne machine interne. C'est le principe du PAT (Port Address Translation).

---

### Exercice 15 -- IPv6 : notation abrégée

**Enoncé** : Abréger les adresses IPv6 suivantes.

1. `2001:0db8:0000:0000:0000:0000:0000:0001`
2. `fe80:0000:0000:0000:0a00:27ff:fe8c:b5d1`
3. `0000:0000:0000:0000:0000:0000:0000:0001`
4. `2001:0db8:abcd:0000:0000:0000:1234:5678`
5. `ff02:0000:0000:0000:0000:0000:0000:0001`

**Correction** :

1. `2001:0db8:0000:0000:0000:0000:0000:0001`
   - Supprimer les zéros en tête : `2001:db8:0:0:0:0:0:1`
   - Remplacer la plus longue suite de groupes nuls par `::` : **`2001:db8::1`**

2. `fe80:0000:0000:0000:0a00:27ff:fe8c:b5d1`
   - Supprimer les zéros en tête : `fe80:0:0:0:a00:27ff:fe8c:b5d1`
   - Remplacer `0:0:0` par `::` : **`fe80::a00:27ff:fe8c:b5d1`**

3. `0000:0000:0000:0000:0000:0000:0000:0001`
   - Supprimer les zéros en tête : `0:0:0:0:0:0:0:1`
   - Remplacer par `::` : **`::1`** (adresse de loopback IPv6)

4. `2001:0db8:abcd:0000:0000:0000:1234:5678`
   - Supprimer les zéros en tête : `2001:db8:abcd:0:0:0:1234:5678`
   - Remplacer `0:0:0` par `::` : **`2001:db8:abcd::1234:5678`**

5. `ff02:0000:0000:0000:0000:0000:0000:0001`
   - Supprimer les zéros en tête : `ff02:0:0:0:0:0:0:1`
   - Remplacer par `::` : **`ff02::1`** (multicast tous les noeuds du lien)

---

### Exercice 16 -- Calcul complet en binaire avec masque /22

**Enoncé** : L'adresse `172.16.45.130/22`. Trouver l'adresse réseau, le broadcast, le nombre d'hôtes, la première et la dernière adresse utilisable. Montrer chaque étape en binaire.

**Correction** :

Etape 1 -- Conversion en binaire :

```
172   = 10101100
16    = 00010000
45    = 00101101
130   = 10000010

IP    : 10101100.00010000.00101101.10000010

Masque /22 : 11111111.11111111.11111100.00000000
           = 255.255.252.0
```

Etape 2 -- ET logique (adresse réseau) :

```
IP     : 10101100.00010000.00101101.10000010
Masque : 11111111.11111111.11111100.00000000
         ────────────────────────────────────
Réseau : 10101100.00010000.00101100.00000000
```

Détail du 3e octet :

```
45     : 00101101
Masque : 11111100
AND    : 00101100 = 44
```

```
Adresse réseau : 172.16.44.0
```

Etape 3 -- Broadcast (bits hôte à 1) :

```
Réseau    : 10101100.00010000.00101100.00000000
                                ^^^^^^.^^^^^^^^
                                Bits hôte (10 bits)

Broadcast : 10101100.00010000.00101111.11111111
```

3e octet broadcast :

```
00101100 → on met les 2 bits de poids faible à 1 → 00101111 = 47
```

```
Broadcast : 172.16.47.255
```

Etape 4 -- Nombre d'hôtes :

```
Bits hôte = 32 - 22 = 10
Hôtes = 2^10 - 2 = 1024 - 2 = 1022
```

Etape 5 -- Récapitulatif :

```
Adresse réseau    : 172.16.44.0
Première adresse  : 172.16.44.1
Dernière adresse  : 172.16.47.254
Broadcast         : 172.16.47.255
Nombre d'hôtes    : 1022
```

---

### Exercice 17 -- Résolution DNS pas à pas

**Enoncé** : Un utilisateur tape `https://www.bts-sio.fr` dans son navigateur. Décrire les étapes de résolution DNS en supposant que les caches sont vides.

**Correction** :

1. Le navigateur interroge le **résolveur stub** du système d'exploitation.
2. Le système vérifie le fichier `hosts` (`/etc/hosts` sous Linux, `C:\Windows\System32\drivers\etc\hosts` sous Windows). Le nom n'y est pas.
3. Le système envoie une requête DNS **récursive** au **résolveur récursif** configuré (ex. : `8.8.8.8`).
4. Le résolveur récursif interroge un **serveur racine** (ex. : `a.root-servers.net`).
   - Réponse : "Je ne connais pas `www.bts-sio.fr`, mais voici les serveurs NS de la zone `.fr`."
5. Le résolveur interroge un **serveur TLD `.fr`** (ex. : `d.nic.fr`).
   - Réponse : "Je ne connais pas `www.bts-sio.fr`, mais voici les serveurs NS de `bts-sio.fr`."
6. Le résolveur interroge le **serveur autoritaire** de `bts-sio.fr` (ex. : `ns1.bts-sio.fr`).
   - Réponse : "L'enregistrement A de `www.bts-sio.fr` est `X.X.X.X`."
7. Le résolveur met en cache la réponse (selon le TTL) et la retourne au client.
8. Le système transmet l'adresse IP au navigateur.
9. Le navigateur établit une connexion TCP (puis TLS car HTTPS) vers `X.X.X.X:443`.

---

### Exercice 18 -- Questions rapides (QCM corrigé)

**1. Combien de bits comporte une adresse MAC ?**
Réponse : **48 bits** (6 octets).

**2. Quel protocole de couche 4 utilise le three-way handshake ?**
Réponse : **TCP**.

**3. Sur quel port par défaut écoute un serveur HTTPS ?**
Réponse : **443** (TCP).

**4. Quel est le rôle du TTL dans un paquet IP ?**
Réponse : Le TTL (Time To Live) est un compteur décrémenté de 1 par chaque routeur. Quand il atteint 0, le paquet est détruit et un message ICMP "Time Exceeded" est renvoyé. Cela évite qu'un paquet boucle indéfiniment.

**5. Quelle est la différence entre un hub et un switch ?**
Réponse : Le **hub** retransmet les données sur tous ses ports (couche 1, domaine de collision unique). Le **switch** retransmet les données uniquement vers le port du destinataire grâce à sa table MAC (couche 2, un domaine de collision par port).

**6. Quelle commande affiche la table ARP sous Windows ?**
Réponse : `arp -a`.

**7. Combien d'hôtes utilisables dans un réseau /30 ?**
Réponse : 2^2 - 2 = **2 hôtes** (utilisé pour les liaisons point à point entre routeurs).

**8. L'adresse 172.32.1.1 est-elle privée ?**
Réponse : **Non**. La plage privée de classe B va de 172.16.0.0 à 172.31.255.255. L'adresse 172.32.1.1 est en dehors de cette plage (32 > 31), c'est donc une adresse **publique**.

Vérification en binaire :
```
172.31.x.x  → 2e octet : 00011111 (31) → dans la plage /12
172.32.x.x  → 2e octet : 00100000 (32) → hors de la plage /12
```

**9. Quel type d'enregistrement DNS permet de définir un alias ?**
Réponse : **CNAME** (Canonical Name).

**10. Quel protocole remplace ARP en IPv6 ?**
Réponse : **NDP** (Neighbor Discovery Protocol), en particulier les messages ICMPv6 Neighbor Solicitation et Neighbor Advertisement.

---

## 18. Résumé des formules essentielles

| Calcul | Formule |
|--------|---------|
| Nombre d'hôtes utilisables | 2^h - 2 (h = bits hôte = 32 - masque CIDR) |
| Nombre de sous-réseaux | 2^s (s = bits empruntés) |
| Taille du bloc (pas) | 2^h |
| Adresse réseau | IP AND Masque (ET logique bit à bit) |
| Adresse de broadcast | Adresse réseau OR NOT Masque (bits hôte tous à 1) |
| Première adresse utilisable | Adresse réseau + 1 |
| Dernière adresse utilisable | Broadcast - 1 |
| Nombre de liaisons (maillage complet) | n(n-1)/2 |

---

## 19. Tableau de référence : puissances de 2

| n | 2^n | 2^n - 2 (hôtes) |
|---|-----|-----------------|
| 1 | 2 | 0 |
| 2 | 4 | 2 |
| 3 | 8 | 6 |
| 4 | 16 | 14 |
| 5 | 32 | 30 |
| 6 | 64 | 62 |
| 7 | 128 | 126 |
| 8 | 256 | 254 |
| 9 | 512 | 510 |
| 10 | 1024 | 1022 |
| 11 | 2048 | 2046 |
| 12 | 4096 | 4094 |
| 13 | 8192 | 8190 |
| 14 | 16384 | 16382 |
| 15 | 32768 | 32766 |
| 16 | 65536 | 65534 |
| 24 | 16777216 | 16777214 |

---

## 20. Tableau de référence : conversion rapide des masques

| CIDR | Masque décimal | Dernier octet significatif (binaire) | Taille du bloc |
|------|---------------|--------------------------------------|----------------|
| /8 | 255.0.0.0 | -- | 16 777 216 |
| /9 | 255.128.0.0 | 10000000 | 8 388 608 |
| /10 | 255.192.0.0 | 11000000 | 4 194 304 |
| /11 | 255.224.0.0 | 11100000 | 2 097 152 |
| /12 | 255.240.0.0 | 11110000 | 1 048 576 |
| /13 | 255.248.0.0 | 11111000 | 524 288 |
| /14 | 255.252.0.0 | 11111100 | 262 144 |
| /15 | 255.254.0.0 | 11111110 | 131 072 |
| /16 | 255.255.0.0 | -- | 65 536 |
| /17 | 255.255.128.0 | 10000000 | 32 768 |
| /18 | 255.255.192.0 | 11000000 | 16 384 |
| /19 | 255.255.224.0 | 11100000 | 8 192 |
| /20 | 255.255.240.0 | 11110000 | 4 096 |
| /21 | 255.255.248.0 | 11111000 | 2 048 |
| /22 | 255.255.252.0 | 11111100 | 1 024 |
| /23 | 255.255.254.0 | 11111110 | 512 |
| /24 | 255.255.255.0 | -- | 256 |
| /25 | 255.255.255.128 | 10000000 | 128 |
| /26 | 255.255.255.192 | 11000000 | 64 |
| /27 | 255.255.255.224 | 11100000 | 32 |
| /28 | 255.255.255.240 | 11110000 | 16 |
| /29 | 255.255.255.248 | 11111000 | 8 |
| /30 | 255.255.255.252 | 11111100 | 4 |
| /31 | 255.255.255.254 | 11111110 | 2 |
| /32 | 255.255.255.255 | 11111111 | 1 |
